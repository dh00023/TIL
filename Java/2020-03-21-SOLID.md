# 객체지향 설계 원칙(SOLID)

SOLID는 아래 다섯가지 원칙을 의미한다.

- **S**PR(Single Responsibility Principle) 단일 책임 원칙
- **O**CP(Open Closed Principle) 개방 폐쇄 원칙
- **L**SP(Liskov Substitution Principle) 리스코프 치환 원칙
- **I**SP(Interface Segregation Principle) 인터페이스 분리 원칙
- **D**IP(Dependency Inversion Principle) 의존 역전 원칙



## Single Responsibility Principle

"한 클래스는 하나의 원칙만 가지고 있어야한다."

단일 클래스는 오직 한 가지 일에만 책임이 있어야 한다. 만약 하나의 클래스가 하나 이상의 책임이 있다면, 이것은 결합(Coupled)를 불러올 수 있다. 하나의 책임에 대한 변경은 다른 책임의 수정을 발생시키게 된다.

SRP원리를 적용하면 무엇보다도 책임 영역이 확실해지기 때문에 한 책임의 변경에서 **다른 책임의 변경으로의 연쇄작용에서 자유**로워 진다. 뿐만 아니라 책임을 적절히 분배함으로써 **코드의 가독성 향상, 유지보수 용이** 해진다. 객체지향 원리의 대전제 격인 OCP원리뿐 아니라 다른 원리들을 적용하는 기초가 되는 원칙이다.

하지만, 실무에서는 **하나의 책임**이라는 것은 모호할 수 있다.
- 하나의 책임이 클 수 있고, 작을 수 있으며, 문맥과 상황에 따라 다르다.
- **중요한 기준은 변경**이다. 변경이 있을 때 파급효과가 적으면 단일 책임원칙을 잘 지키고 있는 것이다.

## Open Closed Principle

"클래스나 모듈은 **확장에는 열려**있으나, **변경에는 닫혀**있어야한다."

OCP는 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화 해야 한다는 의미로, 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻이다.

1. 변경(확장)될 것과 변하지 않을 것을 엄격히 구분
2. 이 두 모듈이 만나는 지점에 인터페이스를 정의
3. 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성

다형성을 잘 활용하여 구현할 수 있다.

## Liskov Substitution Principle

"서브 타입은 언제나 기반 타입으로 교체할 수 있어야한다."

즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 수행하는 데 문제가 없어야 한다. 이것은 OOP 4대 특성의 상속, 인터페이스 원칙이 잘 지켜진 다면 LSP는 잘 적용 된 것이다.

상속은 구현상속(extends)이든 인터페이스 상속(implements)이든 궁극적으로는 다형성을 통한 확장성 획득을 목표로 한다. LSP원리도 역시 서브 클래스가 확장에 대한 인터페이스를 준수해야 함을 의미한다.

- ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반! 느리더라도 앞으로 가야한다.

## Interface Segregation Principle

"하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다"

ISP는 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리이다. 즉, 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 한다.

SRP가 클래스의 단일책임을 강조한다면 ISP는 인터페이스의 단일책임을 강조한다. 하지만 ISP는 어떤 클래스 혹은 인터페이스가 여러 책임 혹은 역할을 갖는 것을 인정한다. SRP가 클래스 분리를 통해 변화에 적응성을 획득하는 반면, ISP에서는 인터페이스 분리를 통해 같은 목표에 도달 한다.

- ex) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- ex) 사용자 인터페이스 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리시 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음

**인터페이스가 명확해지고, 대체 가능성이 높아진다.**

### Dependency Inversion Principle

"추상화에 의존해야하며, 구체화에 의존하면 안된다."

- 상위 모듈은 하위 모듈의 구현에 의존해서는 안 된다.
- 하위의 모듈이 상위 모듈에 정의한 추상 타입(interface)에 의존 해야한다.

즉, 자신보다 변하기 쉬운 것에 의존하면 안된다는 의미이다.

## 참고

- [NEXTREE - 객체지향 개발 5대 원리: SOLID](http://www.nextree.co.kr/p6960/)

- [빨간색코딩 - 객체지향 설계 5원칙 SOLID ](https://sjh836.tistory.com/159)
- [Yun Blog - Spring 예제로 보는 SOLID DIP](https://cheese10yun.github.io/spring-solid-dip/)