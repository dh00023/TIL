# ITEM 64: 객체는 인터페이스를 사용해 참조해라

[ITEM 51: 매개변수의 타입으로는 클래스보다 인터페이스가 낫다](https://github.com/dh00023/TIL/blob/master/Java/effective_java/2021-07-05-design-method-signatures-carefully.md#-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%9D%98-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B0%80-%EB%82%AB%EB%8B%A4) 의 연장선으로 객체는 클래스가 아닌 인터페이스로 참조하라까지 확장할 수 있다.
**적합한 인터페이스만 있다면 매개변수, 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언**해야한다. 실제 클래스를 사용해야하는 경우는 생성자로 생성할 때 뿐이다.

```java
// 인터페이스 타입으로 사용 - 좋은 예
Set<Son> sonSet = new LinkedHashSet<>();

// 클래스를 타입으로 사용 - 나쁜 예
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

인터페이스를 타입으로 사용하면, 나중에 구현 클래스를 교체하고자 할때 새 클래스를 호출해주기만 하면 되므로 더 유연해진다.

```java
// 새로운 구현체로 교체
Set<Son> sonSet = new HashSet<>();
```

여기서 주의할 점은 새로운 구현체로 바꿀때 원래 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하고, 이 기능에 기대어 동작한다면, 새로운 클래스도 반드시 같은 기능을 제공해야된다는 것이다.
예를 들어, `LinkedHashSet` 은 순서 정책을 가정하고 동작하는 코드를 순서를 보장하지 않는 `HashSet` 으로 바꾸면 문제가 될 수 있다.

#### 적합한 인터페이스가 없는 경우

- `String` 과 `BigInteger` 와 같은 값 클래스
- 클래스 기반으로 작성된 프레임워크가 제공하는 객체
    - `java.io`  패키지의 클래스 (`OutputStream`)
- 인터페이스에는 없는 특별한 메서드를 제공하는 클래스
    - `PriorityQueue` : `Queue` 인터페이스에 없는 `comparator` 메서드 제공
    - 클래스 타입을 사용하는 경우 추가 메서드를 꼭 사용해야하는 경우를 최소화 해야한다.

**적합한 인터페이스가 없다면 클래스 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위) 클래스를 타입으로 사용**하는 것이 좋다.

