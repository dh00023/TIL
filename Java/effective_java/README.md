# Effective Java 3/E

![https://image.yes24.com/goods/65551284/800x0](https://image.yes24.com/goods/65551284/800x0)

- [이펙티브 자바 3판 Github](https://github.com/WegraLee/effective-java-3e-source-code)


## Summary

* [ITEM 1: Static Factory Method(정적 메소드)](./2021-01-12-static-factory-methods.md)
* [ITEM 2: Builder Pattern](./2021-01-13-builder-pattern.md)
* [ITEM 3: Singleton](./2021-01-14-singleton.md)
* [ITEM 4: Private Constructor](./2021-01-16-private-constructor.md)
* [ITEM 5: Dependency Injection](./2021-01-16-dependency-injection.md)
* [ITEM 6: Avoid Unnecessary Object](./2021-01-22-avoid-unnecessary-object.md)
* [ITEM 7: Eliminate Object Reference](./2021-01-22-eliminate-object-reference.md)
* [ITEM 8: Avoid finalizer and cleaner](./2021-01-25-avoid-finalizer-and-cleaner.md)
* [ITEM 9: try-with-resources](./2021-01-25-try-with-resources.md)
* [ITEM 10: The gerneral contract when overriding equlas](./2021-02-01-overriding-equals.md)
* [ITEM 11: Overriding hashCode](./2021-02-02-overriding-hashCode.md)
* [ITEM 12: overriding toString](./2021-02-03-overriding-toString.md)
* [ITEM 13: overriding clone judiciously](./2021-02-03-overriding-clone-judiciously.md)
* [ITEM 14: Consider implementing comparable](./2021-02-04-comparable.md)
* [ITEM 15: 클래스와 멤버의 접근을 최소화해라](./2021-02-11-minimize-class-and-memeber.md)
* [ITEM 16: Use Accessor methods](./2021-02-11-use-accessor-method.md)
* [ITEM 17: 변경 가능성을 최소화해라(불변 클래스)](./2021-02-11-minimize-mutability.md)
* [ITEM 18: 상속보단 컴포지션을 사용해라](./2021-02-12-use-composition.md)
* [ITEM 19: 상속을 고려해 설계하고 문서화해라](./2021-02-13-design-inheirtance.md)
* [ITEM 20: 추상 클래스보다 인터페이스를 우선하라](./2021-02-13-prefer-interface.md)
* [ITEM 21: 인터페이스는 구현하는 쪽을 생각해 설계해라.](./2021-02-13-design-interface-for-posterity.md)
* [ITEM 22: 인터페이스는 타입을 정의하는 용도로만 사용해라](./2021-02-13-use-interface-to-define-type.md)
* [ITEM 23: 태그 달린 클래스보다 클래스 계층구조를 활용해라](./2021-02-14-use-class-hirarchies.md)
* [ITEM 24: 멤버 클래스는 되도록 static으로 구현해라](./2021-02-14-favor-static-memeber.md)
* [ITEM 25: 톱레벨 클래스는 한 파일에 하나만 생성해라.](./2021-02-14-limit-single-top-level-class.md)
* [ITEM 26: Raw type은 사용하지 마라](./2021-05-19-generic-dont-use-raw-type.md)
* [ITEM 27: 비검사 경고를 제거해라](./2021-05-20-remove-unchecked-warning.md)
* [ITEM 28: 배열보다는 리스트를 사용해라](./2021-05-21-use-list-rather-than-array.md)
* [ITEM 29: 이왕이면 제네릭 타입으로 만들어라](./2021-05-22-make-generic-type.md)
* [ITEM 30: 이왕이면 제네릭 메서드로 만들어라](./2021-05-29-make-generic-method.md)
* [ITEM 31 : 한정적 와일드카드를 사용해 API 유연성을 높여라](./2021-05-30-use-bounded-wildcards.md)
* [ITEM 32: 제네릭과 가변인수를 함께 쓸 때는 신중해라](./2021-05-30-careful-when-using-generic-and-varargs.md)
* [ITEM 33: 타입 안전 이종 컨테이너를 고려해라](2021-05-31-consider-type-safe-heterogeneous-container.md)
* [ITEM 34: int 상수 대신 열거 타입을 사용해라](./2021-06-05-use-enum-type.md)
* [ITEM 35: ordinal 메서드 대신 인스턴스 필드를 사용해라](./2021-06-06-use-instant-field.md)
* [ITEM 36: 비트 필드 대신 EnumSet을 사용해라](./2021-06-06-use-enumset.md)
* [ITEM 37: ordinal 인덱싱 대신 EnumMap을 사용해라](./2021-06-06-use-enummap.md)
* [ITEM 38: 확장할 수 있는 열거타입이 필요하면 인터페이스를 사용해라](./2021-06-06-enum-type-implements-interface.md)
* [ITEM 39: 명명 패턴보다 애너테이션을 사용해라](./2021-06-13-use-annotation.md)
* [ITEM 40: @Override 어노테이션을 일관되게 사용해라](./2021-06-14-consistently-use-override-annotation.md)
* [ITEM 41: 정의하려는 것이 타입이라면 마커 인터페이스를 사용해라](./2021-06-14-use-marker-interfaces-to-define-types.md)
* [ITEM 42: 익명 클래스보다는 람다를 사용해라](./2021-06-19-prefer-lambdas-to-anonymous-classes.md)
* [ITEM 43: 람다보다는 메서드 참조를 사용해라](./2021-06-20-prefer-method-references-to-lambdas.md)
* [ITEM 44: 표준 함수형 인터페이스를 사용해라](./2021-06-20-favor-the-use-of-standard-functional-interfaces.md)
* [ITEM 45: 스트림은 주의해서 사용해라](./2021-06-20-use-streams-judiciously.md)
* [ITEM 46: 스트림에서 부작용 없는 함수를 사용해라](./2021-06-27-prefer-side-effect-free-fucntional-interface.md)
* [ITEM 47: 반환 타입으로는 스트림보다 컬렉션이 낫다.](./2021-06-28-prefer-collection-to-stream-as-retrun-type.md)
* [ITEM 48: 스트림 병렬화는 주의해서 사용해라](./2021-06-28-use-caution-when-making-streams-pararrel.md)
