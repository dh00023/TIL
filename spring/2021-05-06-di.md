# 의존관계 주입

## 의존관계 주입 종류

의존관계 주입에는 크게 4가지 방법이 있다.

1. 생성자 주입
2. 수정자 주입(setter)
3. 필드 주입
4. 일반 메서드 주입

### 수정자 주입

```java
@Component
public class OrderServiceImpl implements OrderService{
    
    private  MemberRepository memberRepository;
    private  DiscountPolicy discountPolicy;

  	@Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
		
  	@Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

수정자 메서드(setter)를 통해서 의존관계를 주입한다. **선택, 변경** 가능성이 있는 의존관계에서 사용된다. 

```java
@Component
public class OrderServiceImpl implements OrderService{
    
    private  MemberRepository memberRepository;
    private  DiscountPolicy discountPolicy;

  	@Autowired(required = false)
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
		
  	@Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

`@Autowired` 의 default는 주입할 대상이 없으면 오류가 발생하지만, `@Autowired(required = false)` 로 설정하면, 주입할 대상이 없어도 동작하게 할 수 있다.

### 필드 주입

```java

@Component
public class OrderServiceImpl implements OrderService{

    @Autowired
    private MemberRepository memberRepository;
    @Autowired
    private final DiscountPolicy discountPolicy;

}
```

- 코드가 간결
- 외부에서 변경이 불가능해서 테스트하기 힘들다는 치명적인 단점
- DI 프레임워크가 없으면 아무것도 할 수 없다.
- **실무에서는 사용하지 않는 것을 권장**
  - 애플리케이션의 실제 코드와 관계 없는 **테스트 코드**
  - 스프링 설정을 목적으로 하는 `@Configuration` 같이 특별한 용도로 사용

### 일반 메서드 주입

```java
@Component
public class OrderServiceImpl implements OrderService{
		private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Autowired
    public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
}
```

- 한번에 여러 필드를 주입받을 수 있다.
- 일반적으로 잘 사용하지 않는다.


### 생성자 주입

생성자를 통해서 의존 관계를 주입받는 방법이다. 생성자 호출시점에 딱 1번만 호출되는 것이 보장되며, **불편, 필수** 의존관계에 사용된다.

```java
@Component
public class OrderServiceImpl implements OrderService{

  	// final은 반드시 값이 있어야한다.
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
}
```

**생성자가 1개만 있으면, @Autowired를 생략해도 자동 주입된다.**

과거에는 수정자 주입과 필드 주입을 많이 사용했지만, 최근에는 대부분이 생성자 주입을 권장한다.

#### 불변

- 대부분의 의존 관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
  - 대부분 의존 관계는 애플리케이션 종료 전까지 변하면 안된다.
- 수정자 주입의 경우 `setXxx` 메서드를 public 으로 선언해야한다.
  - public으로 설정하게 되는 경우, 누군가가 실수로 변경할 수도 있을뿐더러, 변경이 되면 안되는 메서드를 public으로 설정하는 것은 좋은 설계가 아니다.
- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로, 불변하게 설계가 가능하다.

#### 누락

프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우에는 

```java
@Component
public class OrderServiceImpl implements OrderService{
    
    private  MemberRepository memberRepository;
    private  DiscountPolicy discountPolicy;

  	@Autowired(required = false)
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
		
  	@Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

```java
class OrderServiceImplTest {
	@Test
  void createOrder() {
      OrderServiceImpl orderService = new OrderServiceImpl();
      orderService.createOrder(1L, "itemA", 10000);
  }  
}
```

```java
java.lnag.NullPointerException
//  ...
```

memberRepository, discountPolicy 모두 의존관계 주입이 누락되었기 때문에 실행은 되나  `NullPointException` 이 발생한다.

```java
@Component
public class OrderServiceImpl implements OrderService{

  	// final은 반드시 값이 있어야한다.
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
}
```

```java
class OrderServiceImplTest {
	@Test
  void createOrder() {
      OrderServiceImpl orderService = new OrderServiceImpl();
      orderService.createOrder(1L, "itemA", 10000);
  }  
}
```

생성자 주입을 사용하면  주입 데이터를 누락 했을 때 **컴파일 오류**가 발생한다. 필요로 하는 타입을 바로 알 수 있기때문에 누락되는 경우가 없다.

```java
java: constructor OrderServiceImpl in class dh0023.springcore.order.service.OrderServiceImpl cannot be applied to given types;
  required: dh0023.springcore.member.repository.MemberRepository,dh0023.springcore.discount.service.DiscountPolicy
  found: no arguments
  reason: actual and formal argument lists differ in length
```

#### final 키워드

```java
@Component
public class OrderServiceImpl implements OrderService {
        private final MemberRepository memberRepository;
        private final DiscountPolicy discountPolicy;
				
      	@Autowired
        public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
            this.memberRepository = memberRepository;
          // this.discountPolicy = discountPolicy;
        }
}
```

생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다. 

```
java: variable discountPolicy might not have been initialized
```

컴파일 단계에서 오류를 발견하는 것은 가장 빠르고 좋은 오류이다. 

수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드를 사용할 수 없으며, **오직 생성자 주입 방식만 final 키워드를 사용할 수 있다.**

- 기본으로 생성자 주입을 사용하고, **필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다**. 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.



## 옵션 처리

주입할 스프링 빈이 없어도 동작해야할 때가 있다.

### @Autowired(require = false)

```java
public class AutowiredTest {

    @Test
    void AutowiredOption() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestBean.class);
        TestBean bean = ac.getBean(TestBean.class);
    }

    static class TestBean {

        @Autowired
        public void setNoBean(Member member) {
            System.out.println("member = " + member);
        }
    }
}

```

bean으로 등록되지 않은 `Member` 클래스를 `@Autowired`를 하면 다음과 같은 오류가 발생한다.

```java
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'autowiredTest.TestBean': Unsatisfied dependency expressed through method 'setNoBean' parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'dh0023.springcore.member.domain.Member' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}

	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.resolveMethodArguments(AutowiredAnnotationBeanPostProcessor.java:768)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:720)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1413)
	....
```

다음과 같이 `@Autowired(required = false)`로  자동주입 대상을 주입할 수 있다.

```java
public class AutowiredTest {

    @Test
    void AutowiredOption() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestBean.class);
        TestBean bean = ac.getBean(TestBean.class);
    }

    static class TestBean {

        @Autowired(required = false)
        public void setNoBean(Member member) {
            System.out.println("member = " + member);
        }
    }
}
```

이 경우에는 **자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안된다.** (로그가 출력이 안되는 것을 확인 가능)

```
23:25:53.088 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@223aa2f7
23:25:53.165 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
23:25:53.630 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor'
23:25:53.637 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
23:25:53.640 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
23:25:53.643 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
23:25:53.819 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'autowiredTest.TestBean'


Process finished with exit code 0
```



### `org.springframework.lang.@Nullable`

```java
public class AutowiredTest {

    @Test
    void AutowiredOption() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestBean.class);
        TestBean bean = ac.getBean(TestBean.class);
    }

    static class TestBean {

        @Autowired
        public void setNoBean(@Nullable Member member) {
            System.out.println("member = " + member);
        }

    }
}
```

`@Nullable` 로 설정할 경우 **자동 주입할 대상이 없으면 null이 입력**된다.

```
23:27:46.560 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@223aa2f7
23:27:46.591 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
23:27:46.721 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor'
23:27:46.730 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
23:27:46.733 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
23:27:46.736 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
23:27:46.757 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'autowiredTest.TestBean'
member = null

Process finished with exit code 0
```

### Optional

```java
public class AutowiredTest {

    @Test
    void AutowiredOption() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestBean.class);
        TestBean bean = ac.getBean(TestBean.class);
    }

    static class TestBean {

        @Autowired
        public void setNoBean(Optional<Member> member) {
            System.out.println("member = " + member);
        }

    }
}
```

`Optional`은 **자동 주입할 대상이 없으면 `Optional.empty` 가 입력**된다.

```
23:27:46.560 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@223aa2f7
23:27:46.591 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
23:27:46.721 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor'
23:27:46.730 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
23:27:46.733 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
23:27:46.736 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
23:27:46.757 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'autowiredTest.TestBean'
member = Optional.empty

Process finished with exit code 0
```



## 참고

- [김영한 스프링 핵심 원리 - 기본편](https://inf.run/deVM)